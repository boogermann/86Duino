This is ../../info/djasm.info, produced by makeinfo version 4.6 from
djasm.txi.

INFO-DIR-SECTION From djdevNNN.zip
START-INFO-DIR-ENTRY
* djasm: (djasm).
        The DJGPP 16-bit Assembler.
END-INFO-DIR-ENTRY


File: djasm.info,  Node: Top,  Next: Introduction,  Up: (dir)



`djasm' is a special-purpose 16-bit assembler used to compile the
16-bit stub that allows DOS to run the COFF files generated by DJGPP.

   This is Edition 1.05 of the documentation for `djasm', `The DJGPP
16-bit Assembler', last updated June 2001, for DJGPP version
2.04.  This manual incorporates the information in Bill Currie's LyX
documentation for `djasm', dated 19 November 1999.

* Menu:

* Introduction::                What is `djasm'?
* Overview::                    Features, differences, and limitations.
* Invocation::                  Invoking `djasm'.
* Language::                    Assembler language reference.
* Examples::                    Programming examples.
* Contributors::                Contributors.
* References::                  Some useful references.
* Topic Index::                 Index of topics.
* Keyword Index::               Index of keywords.
* Mnemonic Index::              Index of mnemonics.


File: djasm.info,  Node: Introduction,  Next: Overview,  Prev: Top,  Up: Top

What is `djasm'?
****************

* Menu:

* Disclaimer::                  Caveat emptor, caveat lector.
* Description::                 Description.
* History::                     A brief history of `djasm'.


File: djasm.info,  Node: Disclaimer,  Next: Description,  Up: Introduction

Disclaimer
==========

     This is an UNREVIEWED and UNGUARANTEED document describing *some*
     of the aspects of djasm.  We think it might describe djasm, but
     then it might not.
                                                                   --DJ

Some features described herein may be specific to Bill Currie's latest
version of `djasm', available at <www.taniwha.org>, and may not (yet)
have found their way into the official DJGPP release.  The final
authority regarding `djasm' is the Bison source file `djasm.y' in the
archive `djlsrNNN.zip'.


File: djasm.info,  Node: Description,  Next: History,  Prev: Disclaimer,  Up: Introduction

Description
===========

`djasm' is a restricted assembler that was developed for a single
purpose: to compile the 16-bit startup stub that is prepended to all
DJGPP-built executables.  The purpose of the stub is to (i) check for
DPMI services, (ii) load CWSDPMI if another DPMI server is not found,
(iii) switch into protected mode, and (iv) load and execute a
DJGPP-generated COFF image.  With `djasm' the DJGPP distribution can be
made completely self-contained; you don't need commercial (or otherwise
non-DJGPP) 16-bit tools to build any part of the DJGPP distribution.

   Be aware, however, that although `djasm' can be used in other
applications, it is _not_ a full-featured assembler; if you need a
sophisticated, general-purpose assembler then consider using AS (the
GNU assembler) or NASM (the Netwide Assembler).  Give some thought to
what you want to do, and choose the right tool for the job.  The GNU
assembler AS (`as.exe') is part of the DJGPP `bnuNNNb.zip' archive and
should be available in the `bin' subdirectory of your DJGPP tree (i.e.,
in `$DJDIR/bin') if you have installed GCC.  The Netwide Assembler NASM
lives at <www.cryogen.com/Nasm>.


File: djasm.info,  Node: History,  Prev: Description,  Up: Introduction

A Brief History of `djasm'
==========================

The need for `djasm' arose when Cygnus, a major user of DJGPP for their
DOS-based products, requested a version of DJGPP that was fully
independent and self-bootstrapping.  The existing DJGPP 1.x system
didn't entirely meet their need, however, because a Borland 16-bit
compiler (Turbo C 2.0) was required to build the `go32.exe' program
used by DJGPP 1.x.

   The first task, therefore, in making a version 2.x of DJGPP that
would be entirely self-contained was to write an assembler that could
compile the 16-bit stub required by all DJGPP executables.  The stub
could have been written to use NASM, but (1) NASM wasn't around at the
time, and (2) a dedicated 16-bit compiler would make DJGPP independent
of any other product.  Thus `djasm' was designed and written for a
specific purpose--to compile the 16-bit code for DJGPP's startup stub
and enable _everything_ needed to build DJGPP to be distributed freely.

   The `djasm' compiler was to have no other purpose in life, and was
never intended to be a generic utility, until some of the developers got
carried away and introduced support for many additional opcodes that had
not yet been used.  As a result, `djasm' has become sufficiently
powerful to be useful for more 16-bit applications than just the DJGPP
stub.


File: djasm.info,  Node: Overview,  Next: Invocation,  Prev: Introduction,  Up: Top

An Overview of `djasm'
**********************

* Menu:

* Features::                    What `djasm' can do.
* Differences::                 Differences from other assemblers.
* Limitations::                 What you don't get with `djasm'.
* Applications::                When would I want to use `djasm'?


File: djasm.info,  Node: Features,  Next: Differences,  Up: Overview

What `djasm' can do
===================

Despite its limitations, `djasm' does have some nice features:

   * The syntax was designed to be easy to parse, so `djasm' is
     relatively easy to learn and use, and code written for `djasm'
     tends to be straightforward.

   * `djasm' is released under the terms of the GPL and comes with
     DJGPP (`djdevNNN.zip').

   * GCC- and AS-generated COFF files can be linked with the code (the
     linking is done by `djasm').

   * `djasm' produces 16-bit code (currently this is the only available
     mode).

   * There is support for several output formats, including raw hex
     output for subsequent use with assembler and C code.

   * C-style structure, union, and enumeration types are supported.

   * Most instructions and addressing modes are supported.

   * Full 32-bit addressing.


File: djasm.info,  Node: Differences,  Next: Limitations,  Prev: Features,  Up: Overview

Differences between `djasm' and other assemblers
================================================

There are some important differences between `djasm' and other
assemblers, such as NASM or the GNU assembler AS.

   * Like most assemblers, `djasm' has its own syntactic idiosyncrasies.
     In general, `djasm' syntax is similar to Intel syntax, and porting
     code to `djasm' shouldn't be difficult.

   * `djasm' generates 16-bit code, AS generates 32-bit code, and NASM
     can generate both 16- and 32-bit code.

   * `djasm' is incompletely documented and has incomplete opcode
     support; AS and NASM are fully supported.

   * `djasm' does not support macros.

   * `djasm' is restricted in its output formats.

   * `djasm' does not support multi-file programs, so all source must
     be in a single file.

   * `djasm' builds `.exe' and other executables directly; there is no
     linker.

   * Code generated by `djasm' cannot be linked with DJGPP programs;
     both NASM and the GNU assembler AS can produce standard COFF
     objects.  However, `djasm' *can* build a raw binary image for
     inclusion in other code.


File: djasm.info,  Node: Limitations,  Next: Applications,  Prev: Differences,  Up: Overview

What's missing from `djasm'?
============================

Although `djasm' can do quite a bit as it stands, there are a number of
things that experienced assembly-language programmers will miss.
Future versions of `djasm' may add support for some or all of these
items, but again, if you need a sophisticated general-purpose
assembler, you should consider AS or NASM.

   * Complete instruction set support.

   * Object files--what format(s)?

   * A companion 16-bit linker.

   * Segments.  (Is this really necessary?  Is it worth it?  Should one
     just use NASM instead?)

   * Macros.

   * More documentation.

   * Finish support for the Tool Interface Standards (TIS) Relocatable
     Object Module Format (OMF).

   * Better symbol handling (allow forward references in most
     expressions).

   * Better section support.  At first, just being able to swap between
     the `.text', `.data', and `.bss' sections at will.  Later, maybe
     `real' segment support (especially 16/32-bit control).

   * Finalize instruction support for 486.

   * Pentium* instructions.



File: djasm.info,  Node: Invocation,  Next: Language,  Prev: Overview,  Up: Top

Invoking `djasm'
****************

Invoke `djasm' as follows:

     djasm INFILE [OUTFILE] [MAPFILE]

where OUTFILE defaults to `INFILE.exe' after dropping the extension
from INFILE, and MAPFILE defaults to `INFILE.map' after dropping the
extension from INFILE.

   The extension of `outfile' determines the format of the generated
code.  The following output formats are supported:

`.exe'
     Generate a normal DOS `.exe' executable (MZ-signature).  Does not
     support more than one segment.  This is the only output format
     that supports the `.copyright' directive.

`.com'
     Generate a normal DOS `.com' file.  Program offset is at 0x100.

`.bin'
`.sys'
     Generate binary files starting at offset 0.  The `.sys' format is
     supported so that device drivers can be built directly (i.e.,
     without needing to rename a `.bin' output file to a `.sys' file).

`.h'
     Produce a C-compilable array of bytes (without type declaration or
     surrounding {}s).

`.inc'
     Produce a `.db' array for other `djasm' `.asm' files.

`.ah'
     Produce a `.byte' array for AS `.s' or `.S' files.

   For the `.h', `.inc', and `.ah' output types, the `.type' directive
is used to determine which binary type to emit (*note .type: General.).


File: djasm.info,  Node: Applications,  Prev: Limitations,  Up: Overview

When would I want to use `djasm'?
=================================

Ordinarily, assembly language programmers should use AS, or a 16/32-bit
assembler like NASM, for most programming purposes.  However, there are
a few reasons why you might want to use `djasm':

   * If you are looking for a free (sensu GPL) 16-bit assembler.

   * To keep a project compatible with the spirit of DJGPP, without
     requiring the use of NASM or some other assembler to compile
     16-bit code.

   * For small 16-bit projects, such as device drivers, TSRs, boot
     loaders, or micro-kernels.


File: djasm.info,  Node: Language,  Next: Examples,  Prev: Invocation,  Up: Top

The `djasm' Language
********************

* Menu:

* Syntax::                      Assembler syntax.
* General::                     General assembler directives.
* Data::                        Data directives.
* Structures::                  Structure, union, and enumeration types.
* Prefixes::                    Segment override prefixes.
* Mnemonics::                   Assembler mnemonics.


File: djasm.info,  Node: Syntax,  Next: General,  Up: Language

Assembler Syntax
================

As a general rule, `djasm' uses the same ordering of operands, and
usually the same instruction names, as do TASM and MASM.

   For ambiguous operand sizes, `djasm' uses operand suffixes instead
of the `word ptr', etc., operand modifiers used by other 16-bit
assemblers.  For example, `djasm' uses `cmpb' instead of `cmp byte'.

   Until documentation for `djasm' is completed, however, you should
examine the `bison' source for `djasm' (in the file `djasm.y') to learn
exactly what the instruction mnemonics and their arguments are.


File: djasm.info,  Node: General,  Next: Data,  Prev: Syntax,  Up: Language

General Directives
==================

`.align'
     Usage:  .align BOUNDARY [, FILL]

     Emit bytes (if necessary) so that the program counter CS:IP
     (denoted by `.') is a multiple of BOUNDARY (i.e., such that CS:IP
     % BOUNDARY == 0).  The argument FILL specifies what bytes to emit;
     the default is 0x90 (NOP).

          .align 4       ; align on a 4-byte boundary, pad using 0x90
          .align 16,0    ; align on a 16-byte boundary, pad using 0x00

`.bss'
     Usage:  .bss

     Signifies the end of generated bytes.  No more bytes will be
     emitted into the image, but space will be reserved so labels can
     be declared after this point to create uninitialized variables.

`.copyright'
     Usage:  .copyright STRING

     Inserts the copyright message STRING into the header of the
     executable, starting approximately at offset 0x61 (there is also
     some text with the generation details of the file starting at
     offset 0x28).  STRING is a standard C string.  Multiple
     `.copyright' directives concatenate.  This directive is currently
     supported only for the `.exe' output format.

`.id'
     Usage:  .id

     Emit SCCS and RCS identification strings into the instruction
     stream.  These strings have the form:

          $Id: djasm.lyx,v 1.2 1999/06/22 07:08:56 bill Exp $
          @(#) foo.asm built 10/04/97 14:03:30 by djasm

`.include'
     Usage:  .include "FILE.inc"

     Include a text file for assembly.  `djasm' pushes the current file
     location, starts processing the included file, then pops the old
     location when the end of the included file is reached.  No path
     searching is performed to find the `.include'ed file, but FILE.inc
     itself can include a path specification.

`.linkcoff'
     Usage:  .linkcoff "FILE.o"

     Link in an AS-generated 32-bit COFF file (e.g., the output from
     `gcc -c foo.c').  Currently supports only i386 COFF files with
     `.text', `.data', and `.bss' sections; these _must_ be the first
     three sections in the COFF file and _must_ appear in that order.
     Any other sections will be ignored.  These three sections will be
     placed into the output image in the same order as in the COFF file.
     The `.bss' section of the COFF file will be placed into the output
     image by emitting the appropriate number of zeros--this means that
     the `.bss' section from the COFF file will occupy space in the
     output image rather than being implicit.

     As with `.include', no path searching is done for `.linkcoff', but
     FILE.o itself can include a path specification.

`.org'
     Usage:  .org OFFSET

     Sets the instruction pointer IP to OFFSET.  The IP can only be
     increased using `.org', never decreased.

`.stack'
     Usage:  .stack

     For `.exe' files only, sets the initial value of the stack pointer
     SP to the current value of the instruction pointer IP.

`.start'
     Usage:  .start

     For `.exe' files only, sets the initial value of the instruction
     pointer IP to the current value of the program counter CS:IP.

`.type'
     Usage:  .type "IMAGE"

     where IMAGE is one of `com', `bin', `sys', `h', `inc', or `ah'.
     The following table summarizes the effect of various combinations
     of output file extension and `.type' declaration.

     +---------+-----------------------------------------------------+
     | Output  | Value of `.type'                                    |
     |  file   +-----------------------------------------------------+
     |extension| exe     com     bin     sys(b)  h       inc     ah  |
     +---------+-----------------------------------------------------+
     |  exe(c) | exe     exe(a)  exe     exe     exe     exe     exe |
     |  com    | ---     com     ---     ---     ---     ---     --- |
     |  bin    | bin     bin(a)  bin     bin     bin     bin     bin |
     |  sys(b) | bin     bin(a)  bin     bin     bin     bin     bin |
     |  h      | exe     com     bin     bin     exe     bin     bin |
     |  inc    | exe     com     bin     bin     exe     bin     bin |
     |  ah     | exe     com     bin     bin     exe     bin     bin |
     +---------+-----------------------------------------------------+


       a. The first 0x100 bytes of the program are 0x90 (NOP), followed
          by the generated code.

       b. The `.sys' type is a synonym for `.bin'.

       c. `.exe' is the default output file extension if no output file
          (or output file extension) is specified.



File: djasm.info,  Node: Data,  Next: Structures,  Prev: General,  Up: Language

Data Directives
===============

The data directives are used to reserve space for byte (8-bit), word
(16-bit), and double word (32-bit) data.  The allocated space may be
initialized or left indeterminate.  The general syntax of the data
allocation directives is:

     .db [dblist [','dblist...]]
     .dw [dwlist [','dwlist...]]
     .dd [ddlist [','ddlist...]]

`.db'
     Define a byte of data.

`.dd'
     Define a word of data.

`.dw'
     Define a double word of data.

`.dblist'
`.dwlist'
`.ddlist'
     List of byte, word, or double word data.


   The data lists `dblist', `dwlist', and `ddlist' are constructed from
the following :

`constant'
     A decimal (e.g., 144), hexadecimal (e.g., 0x90), or character
     (e.g., 'A') constant.

`string'
     A C-style string constant, e.g., `"This is a string."'.

`UID offset'
     This item is available only for the `dwlist' and `ddlist'
     directives.

`const .dup const'
     Repeat a block of data.


File: djasm.info,  Node: Structures,  Next: Prefixes,  Prev: Data,  Up: Language

Structures
==========

The following directives provide support for C-style `struct', `union',
and `enum' constructs.

`.struct'
     Start a structure.

`.union'
     Start a union.

`.enum'
     Define an enumeration type.

`.ends'
     End a structure, union, or enumeration.


* Menu:

* Structures and Unions::       Using structures and unions.
* Enumerations::                Using enumerations.


File: djasm.info,  Node: Structures and Unions,  Next: Enumerations,  Up: Structures

Structures and Unions
---------------------

In their usage, `.struct' is the same as `struct' in C, and `.union' is
the same as `union' in C.  For example, the construct

     .struct FARPTR
             off     .dw
             seg     .dw
     .ends

defines the following symbols:

     FARPTR     = 4          ; size of the `FARPTR' structure
     FARPTR.off = 0          ; offset of `off' in the `FARPTR' structure
     FARPTR.seg = 2          ; offset of `seg' in the `FARPTR' structure

   If, in the above example, the `.union' directive had been used
instead of `.struct', a union would have been defined, capable of
holding an offset or a segment, but not both--thus the construct

     .union FARPTR
            off      .dw
            seg      .dw
     .ends

defines the following symbols:

     FARPTR     = 2          ; size of the `FARPTR' union
     FARPTR.off = 0          ; offset of `off' in the `FARPTR' union
     FARPTR.seg = 0          ; offset of `seg' in the `FARPTR' union

   Nested structures are supported.  Here is an example of a nested
structure `XMS_MOVE' that uses the `FARPTR' structure from the previous
example:

     .struct XMS_MOVE
             length          .dd
             src_handle      .dw
             src_offset      .struct FARPTR
             dst_handle      .dw
             dst_offset      .struct FARPTR
     .ends

This construct defines the following symbols and offsets (the members
of each structure have been indented to illustrate the nesting, and the
size in bytes of each member is given in brackets):

     XMS_MOVE                    = 16        ; size of the XMS_MOVE structure
     XMS_MOVE.length             =  0  [4]
     XMS_MOVE.src_handle         =  4  [2]
       XMS_MOVE.src_offset       =  6
       XMS_MOVE.src_offset.off   =  6  [2]
       XMS_MOVE.src_offset.seg   =  8  [2]
     XMS_MOVE.dst_handle         = 10  [2]
       XMS_MOVE.dst_offset       = 12
       XMS_MOVE.dst_offset.off   = 12  [2]
       XMS_MOVE.dst_offset.seg   = 14  [2]

   Note that `XMS_MOVE.src_offset' and `XMS_MOVE.src_offset.off' share
the same offset, as do `XMS_MOVE.dst_offset' and
`XMS_MOVE.dst_offset.off'--this is so that the offset of the nested
structure or union can be used directly.

   When declaring the members of a structure or union, `.struct' and
`.union' can be used interchangably without changing the resulting
layout of the final construct.  In other words, `.struct' could be used
when defining unions and `.union' can be used when defining structures.
This practice is confusing and is *not* recommended; the appropriate
directive should always be used, but this is not enforced (mostly
because there is no way of detecting it).

   Variables can be declared to be structures or unions.  For example,
the statement

     xms_move_packet .struct XMS_MOVE

has the same effect as

     xms_move_packet:
             xms_move_packet.length:
             .dd 0
             xms_move_packet.src_handle:
             .dw 0
     xms_move_packet.src_offset:
             xms_move_packet.src_offset.off:
             .dw 0
             xms_move_packet.src_offset.seg:
             .dw 0
             xms_move_packet.dst_handle:
             .dw 0
     xms_move_packet.dst_offset:
             xms_move_packet.dst_offset.off:
             .dw 0
             xms_move_packet.dst_offset.seg:
             .dw 0

   It is sometimes desirable to place the structure at a specified
location.  For this purpose, any valid expression using defined symbols
is allowed, not just `.token' or `.token-symbol'.  For example, the
following two lines

     xms_move_packet .struct XMS_MOVE (.) ; doesn't emit any bytes!
     xms_move_packet .struct XMS_MOVE (.-sh_handle_cache)

have the same effect as `X'=`.' or `X'=`.-sh_handle_cache', respectively
(recall that `.' denotes the current program counter), and generate the
following structure:

     xms_move_packet                = X
     xms_move_packet.length         = X
     xms_move_packet.src_handle     = X +  4
     xms_move_packet.src_offset     = X +  6
     xms_move_packet.src_offset.off = X +  6
     xms_move_packet.src_offset.seg = X +  8
     xms_move_packet.dst_handle     = X + 10
     xms_move_packet.dst_offset     = X + 12
     xms_move_packet.dst_offset.off = X + 12
     xms_move_packet.dst_offset.seg = X + 14

   The `(.)' form is useful for initializing structures--just follow
the declaration line by anonymous `.db' or `.dw' or `.dd' lines.
Unfortunately this is prone to error, but it is currently the only way
of doing this.  Any expression that `djasm' can handle as a relocation
is permitted in the parentheses; this can be useful for declaring
structures at some specific address (e.g., the PSP structure or some of
the DOS system tables).


File: djasm.info,  Node: Enumerations,  Prev: Structures and Unions,  Up: Structures

Enumerations
------------

The enumeration type allows arbitrary mnemonic identifiers (the
"enumeration constants") to be mapped to a set of integer values.  The
classical textbook example is that of defining a boolean variable.  The
following construct defines `boolean' as an enumeration type that can
take the values 0 (`false') or 1 (`true').

     .enum   boolean
             false
             true
     .ends

In this example, `pets' is defined to be an enumeration type having
integral values 0 (`bird'), 1 (`cat'), 2 (`dog'), or 3 (`rock').

     .enum   pets
             bird
             cat
             dog
             rock
     .ends

In a `djasm' program the above enumeration types could be referenced as
follows:

     .start
             nop
             mov     ax,true                 ; ax <- 1
             mov     bx,pets.dog             ; bx <- 2
             mov     cx,pets.rock            ; cx <- 3
             mov     dx,pets.bird            ; dx <- 0
             int     0x20

   If the enumeration constants are not explicitly initialized, then
they are assigned consecutive integer values starting with zero.
Explicitly and implicitly initialized enumeration constants can be used
within the same enumeration type, in which case an enumeration constant
without an initializer will be assigned the successor of the previous
enumeration constant.

   In this example, the enumeration constants `foo', `bar', and `e' are
implicitly initialized.  A variable of enumeration type `snafu'
therefore takes one of the following integer values: 0 (`foo'), 1
(`bar'), 1 (`a'), 2 (`b'), 4 (`c'), 8 (`d'), or 9 (`e').

     .enum   snafu
             foo
             bar
             a=1
             b=2
             c=4
             d=8
             e
     .ends


File: djasm.info,  Node: Prefixes,  Next: Mnemonics,  Prev: Structures,  Up: Language

Segment Override Prefixes
=========================

Each prefix directive causes the appropriate instruction prefix byte to
be emitted into the instruction stream.

   Usage:

     prefix
     instruction

where `prefix' can be one of the following:

`.addrsize'
     toggles selection of 16- or 32-bit addressing

     The address size prefix byte (0x67) is emitted--this tells `djasm'
     to interpret the address as either a 32- or a 16-bit value.  For
     instance, it determines whether `di' or `edi' is used as the index
     register for a string instruction.

`.opsize'
     toggles selection of 16- or 32-bit operands

     The data size prefix byte (0x66) is emitted.  This determines the
     size of the operands, distinguishing between `mov ax,bx' and `mov
     eax,ebx', for example.

     The `.addrsize' and `.opsize' opcode prefix bytes are used by
     `djasm' to express the 386's confusing opcode prefix scheme.  For
     backward compatibility with the 8086, instructions have both 16-bit
     and 32-bit forms.  But, their opcodes are identical.  So in a
     32-bit segment the 32-bit forms are used by default, and in 16-bit
     segments the 16-bit forms are used by default.  These prefix bytes
     are used to force the compiler to use the non-default form (e.g.,
     issue a `mov ax,bx' within a 32-bit segment).

`.segcs'
     code segment override

`.segds'
     data segment override

`.seges'
     extra segment override

`.segss'
     stack segment override

`.segfs'
     user segment `f' override

`.seggs'
     user segment `g' override


   The `.seg??' prefixes seem to be most appropriate when used with the
string instructions such as `movs', `stos', etc.).


File: djasm.info,  Node: Mnemonics,  Prev: Prefixes,  Up: Language

Mnemonics
=========

This section documents and describes the `djasm' assembler mnemonics.
For convenience, the organization and classification of the mnemonics
generally follows that of Triebel (1992) (*note Triebel-1992::).

* Menu:

* Data Transfer Instructions::
* Arithmetic Instructions::
* Logic Instructions::
* Shift Instructions::
* Rotate Instructions::
* Bit Test and Bit Scan Instructions::
* Flag Control Instructions::
* Compare and Set Instructions::
* Jump Instructions::
* Subroutine Handling Instructions::
* Loop Handling Instructions::
* String Handling Instructions::


File: djasm.info,  Node: Data Transfer Instructions,  Next: Arithmetic Instructions,  Up: Mnemonics

Data Transfer Instructions
--------------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MOV       mov[bwd]    Move
MOVSX     movsx[bw]   Move (sign-extended)
MOVZX     movzx[bw]   Move (zero-extended)
XCHG      xchg        Exchange
XLAT      xlat        Translat (allows segment override)
XLAT      xlatb       Translat (must use DS)
LEA       lea         Load effective address
LDS       lds         Load register and DS
LES       les         Load register and ES
LSS       lss         Load register and SS
LFS       lfs         Load register and FS
LGS       lgs         Load register and GS


File: djasm.info,  Node: Arithmetic Instructions,  Next: Logic Instructions,  Prev: Data Transfer Instructions,  Up: Mnemonics

Arithmetic Instructions
-----------------------

Addition
........

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ADD       add[bwd]    Add byte or word
ADC       adc[bwd]    Add byte or word with carry
INC       inc[bwd]    Increment byte or word by 1
AAA       aaa         ASCII adjust for addition
DAA       daa         Decimal adjust for addition

Subtraction
...........

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUB       sub[bwd]    Subtract byte or word
SBB       sbb[bwd]    Subtract byte or word with borrow
DEC       dec[bwd]    Increment byte or word by 1
NEG       neg         Negate byte or word
AAS       aas         ASCII adjust for subtraction
DAS       das         Decimal adjust for subtraction

Multiplication and Division
...........................

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MUL       mul[bwd]    Multiply byte or word (unsigned)
IMUL      imul[bwd]   Integer multiply byte or word
AAM       aam         ASCII adjust for multiply
DIV       div[bwd]    Divide byte or word (unsigned)
IDIV      idiv[bwd]   Integer divide byte or word
AAD       aad         ASCII adjust for division
CBW       cbw         Convert byte to word
CWDE      cwde        Convert word to double word in EAX
CWD       cwd         Convert word to double word in DX and AX
CDQ       cdq         Convert double word to quad word


File: djasm.info,  Node: Logic Instructions,  Next: Shift Instructions,  Prev: Arithmetic Instructions,  Up: Mnemonics

Logic Instructions
------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AND       and[bwd]    Logical AND
XOR       xor[bwd]    Logical OR (exclusive)
OR        or[bwd]     Logical OR (inclusive)
NOT       not         Logical NOT


File: djasm.info,  Node: Shift Instructions,  Next: Rotate Instructions,  Prev: Logic Instructions,  Up: Mnemonics

Shift Instructions
------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SHL       shl[bwd]    Shift logical left [1]
SAL       sal[bwd]    Shift arithmetic left
SHR       shr[bwd]    Shift logical right [1]
SHR       sar[bwd]    Shift arithmetic right
SHLD      dshl        Double precision shift left [2]
SHRD      dshr        Double precision shift right [2]

Notes
.....

  1. The mnemonics for the double-precision shifts have changed.  *Note
     Change in Mnemonic Usage: shxd, for additional information.

  2. This mnemonic does not take a `b', `d', or `w' suffix.


Change in Mnemonic Usage
........................

Beginning with the version of `djasm' released with DJGPP v2.04, the
mnemonics `shld' and `shrd' no longer denote Intel's double-precision
shift instructions `SHLD' and `SHRD', respectively.  The correct
mnemonics to use for the double-precision shifts are `dshl' and `dshr'.
Any attempt to write `shld' or `shrd' for a double-precision shift will
generate an error message and the correct mnemonic to use (`dshl' or
`dshr') will be indicated.

   If you are interested, here is the reason for the change.

   The convention in `djasm' is to specify the memory operand size by
appending a `b' (byte), `w' (word), or `d' (double word) suffix to the
mnemonic.  There was one exception, however: in the version of `djasm'
released with DJGPP v2.03, the mnemonics `shld' and `shrd' were used to
denote Intel's double-precision left/right shift instructions.  This
usage was inconsistent with every other instruction that could
reference a byte, word, or double word memory operand (under the
existing convention these mnemonics would be expected to denote left
and right shifts of a double-word memory operand).  However, the
double-precision shifts had been implemented _before_ support was added
for basic shifts of memory operands (at the time, only basic shifts of
register operands had been implemented).

   The cleanest solution was to replace the mnemonics used by `djasm'
for the double-precision shift instructions and reserve `shld' and
`shrd' for basic shifts of a double-word memory operand.  At the time
this change was made (between v2.03 and 2.04) there were no `*.asm'
files in the DJGPP CVS tree that used `shld' or `shrd'.

   It is possible that someone, somewhere, used `shld' or `shrd' to
code for a double-precision shift, but this seems unlikely.  According
to the DJGPP mail archives, these instructions were added by Bill
Currie <bill@taniwha.org>, who soon thereafter recognized the impending
conflict and redefined the mnemonics in his own version of `djasm'.
Unfortunately, his changes did not make it into the stock `djasm.y' at
that time.  Furthermore, documentation for `djasm' has been minimal,
and the only way to know what instructions were supported (and what the
mnemonics were) was to inspect `djasm.y', or to inspect source code
(such as `stub.asm') for `djasm' applications.


File: djasm.info,  Node: Rotate Instructions,  Next: Bit Test and Bit Scan Instructions,  Prev: Shift Instructions,  Up: Mnemonics

Rotate Instructions
-------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ROL       rol[bwd]    Rotate left
ROR       ror[bwd]    Rotate right
RCL       rcl[bwd]    Rotate left through carry
RCR       rcr[bwd]    Rotate right through carry


File: djasm.info,  Node: Bit Test and Bit Scan Instructions,  Next: Flag Control Instructions,  Prev: Rotate Instructions,  Up: Mnemonics

Bit Test and Bit Scan Instructions
----------------------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BSF       bsf         Bit scan forward
BSR       bsr         Bit scan reverse
BT        bt          Bit test
BTC       btc         Bit test and complement
BTR       btr         Bit test and reset
BTS       bts         Bit test and set


File: djasm.info,  Node: Flag Control Instructions,  Next: Compare and Set Instructions,  Prev: Bit Test and Bit Scan Instructions,  Up: Mnemonics

Flag Control Instructions
-------------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LAHF      lahf        Load AH from flags
SAHF      sahf        Store AH into flags
CLC       clc         Clear carry flag
STC       stc         Set carry flag
CMC       cmc         Complement carry flag
CLI       cli         Clear interrupt flag
STI       sti         Set interrupt flag


File: djasm.info,  Node: Compare and Set Instructions,  Next: Jump Instructions,  Prev: Flag Control Instructions,  Up: Mnemonics

Compare and Set Instructions
----------------------------

Compare
.......

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CMP       cmp[bwd]    Compare

Set
...

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SETA      seta        Set byte if above
SETAE     setae       Set byte if above or equal
SETB      setb        Set byte if below
SETBE     setbe       Set byte if below or equal
SETC      setc        Set byte if carry
SETE      sete        Set byte if equal
SETG      setg        Set byte if greater
SETGE     setge       Set byte if greater or equal
SETL      setl        Set byte if less
SETLE     setle       Set byte if less or equal
SETNA     setna       Set byte if not above
SETNAE    setnae      Set byte if not above or equal
SETNB     setnb       Set byte if not below
SETNBE    setnbe      Set byte if not below or equal
SETNC     setnc       Set byte if not carry
SETNE     setne       Set byte if not equal
SETNG     setng       Set byte if not greater
SETNGE    setnge      Set byte if not greater or equal
SETNL     setnl       Set byte if not less
SETNLE    setnle      Set byte if not less or equal
SETNO     setno       Set byte if not overflow
SETNP     setnp       Set byte if not parity
SETNS     setns       Set byte if not sign
SETNZ     setnz       Set byte if not zero
SETO      seto        Set byte if overflow
SETP      setp        Set byte if parity
SETPE     setpe       Set byte if parity even
SETPO     setpo       Set byte if parity odd
SETS      sets        Set byte if sign
SETZ      setz        Set byte if zero


File: djasm.info,  Node: Jump Instructions,  Next: Subroutine Handling Instructions,  Prev: Compare and Set Instructions,  Up: Mnemonics

Jump Instructions
-----------------

Unconditional Jump
..................

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
JMP       jmp[bl]     Unconditional jump  [1]
          jmpf        
          jmpfd       
          jmpl        

Notes
.....

   1 The `l' suffix denotes a jump relative to a 16-bit offset.
     (Shouldn't this be `jmpw' for consistency with other mnemonics?
     Sigh.)


Conditional Jump
................

There are 32 "Jump if Condition" instructions.  The unsuffixed form
denotes a jump to an 8-bit relative offset.  Append the `l' suffix for
jumps to 16-bit relative offsets.  There are jumps to 32-bit relative
offsets as well, but these are not yet implemented in `djasm'.

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
JA        ja[l]       Jump if above
JAE       jae[l]      Jump if above or equal
JB        jb[l]       Jump if below
JBE       jbe[l]      Jump if below or equal
JC        jc[l]       Jump if carry
JCXZ      jcxz        CX register is zero [1]
JECXZ     jecxz       ECX register is zero [1]
JE        je[l]       Jump if equal
JG        jg[l]       Jump if greater
JGE       jge[l]      Jump if greater or equal
JL        jl[l]       Jump if less
JLE       jle[l]      Jump if less or equal
JNA       jna[l]      Jump if not above
JNAE      jnae[l]     Jump if not above nor equal
JNB       jnb[l]      Jump if not below
JNBE      jnbe[l]     Jump if not below nor equal
JNC       jnc[l]      Jump if not carry
JNE       jne[l]      Jump if not equal
JNG       jng[l]      Jump if not greater
JNGE      jnge[l]     Jump if not greater nor equal
JNL       jnl[l]      Jump if not less
JNLE      jnle[l]     Jump if not less nor equal
JNO       jno[l]      Jump if not overflow
JNP       jnp[l]      Jump if not parity
JNS       jns[l]      Jump if not sign
JNZ       jnz[l]      Jump if not zero
JO        jo[l]       Jump if overflow
JP        jp[l]       Jump if parity
JPE       jpe[l]      Jump if parity even
JPO       jpo[l]      Jump if parity odd
JS        js[l]       Jump if sign
JZ        jz[l]       Jump if zero

Notes
.....

   1 There are no long (`l'-suffix) forms for these instructions.



File: djasm.info,  Node: Subroutine Handling Instructions,  Next: Loop Handling Instructions,  Prev: Jump Instructions,  Up: Mnemonics

Subroutine Handling Instructions
--------------------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CALL      call        Subroutine call
          callf       
          callfd      

RET       ret         Return from subroutine
          retd        
          retf        
          retfd       

PUSHF     pushf       Push flags onto stack
PUSHFD    pushfd      Push extended flags onto stack

POPF      popf        Pop flags from stack
POPFD     popfd       Pop extended flags from stack

PUSHA     pusha       Push all 16-bit general registers
POPA      popa        Pop all 16-bit general registers

PUSHAD    pushad      Push all 32-bit general registers
POPAD     popad       Pop all 32-bit general registers

ENTER     enter       Make stack frame
LEAVE     leave       Release stack frame


File: djasm.info,  Node: Loop Handling Instructions,  Next: String Handling Instructions,  Prev: Subroutine Handling Instructions,  Up: Mnemonics

Loop Handling Instructions
--------------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LOOP      loop        Loop
LOOPE     loope       Loop while equal
LOOPZ     loopz       Loop while zero
LOOPNE    loopne      Loop while not equal
LOOPNZ    loopnz      Loop while not zero


File: djasm.info,  Node: String Handling Instructions,  Prev: Loop Handling Instructions,  Up: Mnemonics

String Handling Instructions
----------------------------

Intel     DJASM       Meaning
~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MOVSB     movsb       Move string (byte)
MOVSW     movsw       Move string (word)
MOVSD     movsd       Move string (double word)

CMPSB     cmpsb       Compare strings (byte)
CMPSW     cmpsw       Compare strings (word)
CMPSD     cmpsd       Compare strings (double word)

SCASB     scasb       Scan string (byte)
SCASW     scasw       Scan string (word)
SCASD     scasd       Scan string (double word)

LODSB     lodsb       Load string (byte)
LODSW     lodsw       Load string (word)
LODSD     lodsd       Load string (double word)

STOSB     stosb       Store string (byte)
STOSW     stosw       Store string (word)
STOSD     stosd       Store string (double word)

REP       rep         MOVS/STOS: Repeat while not end of string
REPE      repe        CMPS/SCAS: Repeat while not end of string and
                      strings are equal
REPZ      repz        CMPS/SCAS: Repeat while not end of string and
                      strings are equal
REPNE     repne       CMPS/SCAS: Repeat while not end of string and
                      strings are not equal
REPNZ     repnz       CMPS/SCAS: Repeat while not end of string and
                      strings are not equal

CLD       cld         Clear DF
CLD       std         Set DF


File: djasm.info,  Node: Examples,  Next: Contributors,  Prev: Language,  Up: Top

Programming Examples
********************

Some examples of programming with `djasm'.

* Menu:

* Hello world::                 ``Hello, world'' demo program.
* Enumeration types::           Examples of enumeration types.
* Opcode prefixes::             Example of opcode prefix usage.


File: djasm.info,  Node: Hello world,  Next: Enumeration types,  Up: Examples

"Hello, world" demo program
===========================

     .type   "com"
     .org    0x100                   ; origin for .COM program
     
             mov dx, msg             ; point DX to message
             mov ah, 0x9             ; DOS print string function
             int 0x21
             mov ax, 0x4c00          ; DOS exit with errorlevel
             int 0x21
     msg:
             .db "hello, world\r\n$"

   Enter the above code into a file `hello.asm', then make a DOS `.com'
executable using the command

     djasm hello.asm hello.com hello.map


File: djasm.info,  Node: Enumeration types,  Next: Opcode prefixes,  Prev: Hello world,  Up: Examples

Examples of enumeration types
=============================

Here are a few examples of using enumeration types in `djasm'.  These
are taken directly from the section on enumeration types (*note
Enumerations::).

  1. Use an enumeration to define a new type, `boolean'.  Load register
     AX with the value `false' and register BX with the value `true'.

          .type   "com"
          .org    0x100
          .enum   boolean
                  false
                  true
          .ends
                  mov     ax,boolean.false
                  mov     bx,boolean.true
                  int     0x20

     If you assemble this program with `djasm',

          djasm.exe bool.asm bool.com bool.map

     and inspect the resulting `.map' file, you will find the following
     enumeration definition:

          Address    Symbols by Value
          
          0000:0000  __zero__ (?)
          0000:0000  boolean.false (?)
          0000:0001  boolean.true (?)

     If you inspect the assembled code using DOS `debug', you will see
     that the registers are indeed loaded with the proper values:

          % debug bool.exe
          -u 0100 l 08
          1600:0100 B80000        MOV     AX,0000
          1600:0103 BB0100        MOV     BX,0001
          1600:0106 CD20          INT     20
          -q

  2. This example defines an enumeration type `snafu' and demonstrates
     both implicit and explicit initialization of the enumeration
     constants.  In this example, the enumeration constants `foo',
     `bar', and `e' are implicitly initialized with the values 0, 1,
     and 9, respectively.

          .type   "com"
          .org    0x100
          .enum   snafu
                  foo
                  bar
                  a=1
                  b=2
                  c=4
                  d=8
                  e
          .ends
                  int     0x20

     The `.map' file generated by `djasm' shows the enumeration
     constants and how they were defined:

          Address    Symbols by Value
          
          0000:0000  __zero__ (?)
          0000:0000  snafu.foo (?)
          0000:0001  snafu.a (?)
          0000:0001  snafu.bar (?)
          0000:0002  snafu.b (?)
          0000:0004  snafu.c (?)
          0000:0008  snafu.d (?)
          0000:0009  snafu.e (?)



File: djasm.info,  Node: Opcode prefixes,  Prev: Enumeration types,  Up: Examples

Example of opcode prefix usage
==============================

The following code fragment, taken from `stub.asm' in the
`djlsrNNN.zip' archive, illustrates the use of the `.addrsize' and
`.opsize' opcode prefixes.

               :
             [32-bit instructions]
               :
             .addrsize
             rep
             stosd
               :
             [more 16-bit instructions]
               :
             .opsize
             jmpf    fs:[start_eip]          ; start program

   Here, `.addrsize' toggles from the 32-bit addressing mode to the
16-bit mode, and forces the `stosd' instruction to use `di' instead of
`edi' as the index register.  The `.opsize' directive toggles between
16- and 32-bit operand sizes.  In this example it is being used to jump
to a 32-bit address from a 16-bit segment.


File: djasm.info,  Node: Contributors,  Next: References,  Prev: Examples,  Up: Top

Contributors to `djasm'
***********************

The following individuals (in alphabetical order) have contributed to
`djasm', or to its documentation, or both.  If you have contributed to
`djasm' in some way and are not listed here, please make yourself known.
You can also let us know if your e-mail address is okay.

   * John M. Aldrich <fighteer@cs.com>

   * Bill Currie <bill@taniwha.org>

   * DJ Delorie <dj@delorie.com>

   * Nate Eldredge <nate@cartsys.com>

   * Charles Sandmann <sandmann@clio.rice.edu>

   * Margo Schulter <mschulter@value.net>

   * Martin Stro"mberg <ams@ludd.luth.se>

   * Aaron Ucko <ucko@vax1.rockhurst.edu>

   * Vic <tudor@cam.org>

   * Morten Welinder <terra@diku.dk>

   * Jeff Williams <jeffw@darwin.sfbr.org>

   * Eli Zaretskii <eliz@is.elta.co.il>


File: djasm.info,  Node: References,  Next: Topic Index,  Prev: Contributors,  Up: Top

References
**********

  1. Triebel, Walter A.  1992.  The 80386DX microprocessor:  hardware,
     software, and interfacing.  Englewood Cliffs, NJ: Prentice-Hall.
     ISBN 0-13-249566-X.



File: djasm.info,  Node: Topic Index,  Next: Keyword Index,  Prev: References,  Up: Top

Topic Index
***********

* Menu:

* AS, GNU assembler:                     Differences.
* Borland:                               History.
* Cygnus:                                History.
* disclaimer:                            Disclaimer.
* DJGPP:                                 History.
* features, of djasm:                    Features.
* GAS, GNU assembler:                    Differences.
* history, of djasm:                     History.
* NASM, Netwide assembler <1>:           History.
* NASM, Netwide assembler:               Differences.
* overview, of djasm:                    Overview.
* shld, obsolete usage:                  Shift Instructions.
* shrd, obsolete usage:                  Shift Instructions.
* structure, ending:                     Structures and Unions.
* structure, enumeration:                Enumerations.
* structure, initializing:               Structures and Unions.
* structure, struct:                     Structures and Unions.
* structure, union:                      Structures and Unions.
* stub, DJGPP:                           History.
* syntax, ATT:                           Differences.
* syntax, Intel:                         Differences.
* type, enumeration:                     Enumerations.
* type, struct:                          Structures and Unions.
* type, union:                           Structures and Unions.


File: djasm.info,  Node: Keyword Index,  Next: Mnemonic Index,  Prev: Topic Index,  Up: Top

Keyword Index
*************

* Menu:

* .addrsize:                             Prefixes.
* .align:                                General.
* .bss:                                  General.
* .copyright:                            General.
* .db:                                   Data.
* .dblist:                               Data.
* .dd:                                   Data.
* .ddlist:                               Data.
* .dw:                                   Data.
* .dwlist:                               Data.
* .ends:                                 Structures and Unions.
* .enum:                                 Enumerations.
* .id:                                   General.
* .include:                              General.
* .linkcoff:                             General.
* .opsize:                               Prefixes.
* .org:                                  General.
* .segcs:                                Prefixes.
* .segds:                                Prefixes.
* .seges:                                Prefixes.
* .segfs:                                Prefixes.
* .seggs:                                Prefixes.
* .segss:                                Prefixes.
* .stack:                                General.
* .start:                                General.
* .struct:                               Structures and Unions.
* .type:                                 General.
* .type, ah:                             General.
* .type, bin:                            General.
* .type, com:                            General.
* .type, exe:                            General.
* .type, h:                              General.
* .type, inc:                            General.
* .type, sys:                            General.
* .union:                                Structures and Unions.


File: djasm.info,  Node: Mnemonic Index,  Prev: Keyword Index,  Up: Top

Mnemonic Index
**************

* Menu:

* AAA:                                   Arithmetic Instructions.
* aaa:                                   Arithmetic Instructions.
* AAD:                                   Arithmetic Instructions.
* aad:                                   Arithmetic Instructions.
* aam:                                   Arithmetic Instructions.
* AAM:                                   Arithmetic Instructions.
* aas:                                   Arithmetic Instructions.
* AAS:                                   Arithmetic Instructions.
* adc:                                   Arithmetic Instructions.
* ADC:                                   Arithmetic Instructions.
* add:                                   Arithmetic Instructions.
* ADD:                                   Arithmetic Instructions.
* Add byte or word:                      Arithmetic Instructions.
* Add byte or word with carry:           Arithmetic Instructions.
* and:                                   Logic Instructions.
* AND:                                   Logic Instructions.
* ASCII adjust for addition:             Arithmetic Instructions.
* ASCII adjust for division:             Arithmetic Instructions.
* ASCII adjust for multiply:             Arithmetic Instructions.
* ASCII adjust for subtraction:          Arithmetic Instructions.
* Bit scan forward:                      Bit Test and Bit Scan Instructions.
* Bit scan reverse:                      Bit Test and Bit Scan Instructions.
* Bit test:                              Bit Test and Bit Scan Instructions.
* Bit test and complement:               Bit Test and Bit Scan Instructions.
* Bit test and reset:                    Bit Test and Bit Scan Instructions.
* Bit test and set:                      Bit Test and Bit Scan Instructions.
* BSF:                                   Bit Test and Bit Scan Instructions.
* bsf:                                   Bit Test and Bit Scan Instructions.
* BSR:                                   Bit Test and Bit Scan Instructions.
* bsr:                                   Bit Test and Bit Scan Instructions.
* BT:                                    Bit Test and Bit Scan Instructions.
* bt:                                    Bit Test and Bit Scan Instructions.
* BTC:                                   Bit Test and Bit Scan Instructions.
* btc:                                   Bit Test and Bit Scan Instructions.
* btr:                                   Bit Test and Bit Scan Instructions.
* BTR:                                   Bit Test and Bit Scan Instructions.
* bts:                                   Bit Test and Bit Scan Instructions.
* BTS:                                   Bit Test and Bit Scan Instructions.
* CALL:                                  Subroutine Handling Instructions.
* call:                                  Subroutine Handling Instructions.
* CBW:                                   Arithmetic Instructions.
* cbw:                                   Arithmetic Instructions.
* CDQ:                                   Arithmetic Instructions.
* cdq:                                   Arithmetic Instructions.
* clc:                                   Flag Control Instructions.
* CLC:                                   Flag Control Instructions.
* cld:                                   String Handling Instructions.
* CLD:                                   String Handling Instructions.
* Clear carry flag:                      Flag Control Instructions.
* Clear DF:                              String Handling Instructions.
* Clear interrupt flag:                  Flag Control Instructions.
* cli:                                   Flag Control Instructions.
* CLI:                                   Flag Control Instructions.
* cmc:                                   Flag Control Instructions.
* CMC:                                   Flag Control Instructions.
* CMP:                                   Compare and Set Instructions.
* cmp:                                   Compare and Set Instructions.
* cmpsb:                                 String Handling Instructions.
* CMPSB:                                 String Handling Instructions.
* cmpsd:                                 String Handling Instructions.
* CMPSD:                                 String Handling Instructions.
* CMPSW:                                 String Handling Instructions.
* cmpsw:                                 String Handling Instructions.
* Compare:                               Compare and Set Instructions.
* Compare strings (byte):                String Handling Instructions.
* Compare strings (double word):         String Handling Instructions.
* Compare strings (word):                String Handling Instructions.
* Complement carry flag:                 Flag Control Instructions.
* Convert byte to word:                  Arithmetic Instructions.
* Convert double word to quad word:      Arithmetic Instructions.
* Convert word to double word in DX and AX: Arithmetic Instructions.
* Convert word to double word in EAX:    Arithmetic Instructions.
* CWD:                                   Arithmetic Instructions.
* cwd:                                   Arithmetic Instructions.
* cwde:                                  Arithmetic Instructions.
* CWDE:                                  Arithmetic Instructions.
* CX register is zero:                   Jump Instructions.
* DAA:                                   Arithmetic Instructions.
* daa:                                   Arithmetic Instructions.
* DAS:                                   Arithmetic Instructions.
* das:                                   Arithmetic Instructions.
* DEC:                                   Arithmetic Instructions.
* dec:                                   Arithmetic Instructions.
* Decimal adjust for addition:           Arithmetic Instructions.
* Decimal adjust for subtraction:        Arithmetic Instructions.
* DIV:                                   Arithmetic Instructions.
* div:                                   Arithmetic Instructions.
* Divide byte or word (unsigned):        Arithmetic Instructions.
* Double-precision shift left:           Shift Instructions.
* Double-precision shift right:          Shift Instructions.
* dshl:                                  Shift Instructions.
* dshr:                                  Shift Instructions.
* ECX register is zero:                  Jump Instructions.
* ENTER:                                 Subroutine Handling Instructions.
* enter:                                 Subroutine Handling Instructions.
* Exchange:                              Data Transfer Instructions.
* IDIV:                                  Arithmetic Instructions.
* idiv:                                  Arithmetic Instructions.
* imul:                                  Arithmetic Instructions.
* IMUL:                                  Arithmetic Instructions.
* inc:                                   Arithmetic Instructions.
* INC:                                   Arithmetic Instructions.
* Increment byte or word by 1:           Arithmetic Instructions.
* Integer divide byte or word:           Arithmetic Instructions.
* Integer multiply byte or word:         Arithmetic Instructions.
* JA:                                    Jump Instructions.
* ja:                                    Jump Instructions.
* jae:                                   Jump Instructions.
* JAE:                                   Jump Instructions.
* JB:                                    Jump Instructions.
* jb:                                    Jump Instructions.
* jbe:                                   Jump Instructions.
* JBE:                                   Jump Instructions.
* JC:                                    Jump Instructions.
* jc:                                    Jump Instructions.
* JCXZ:                                  Jump Instructions.
* jcxz:                                  Jump Instructions.
* JE:                                    Jump Instructions.
* je:                                    Jump Instructions.
* JECXZ:                                 Jump Instructions.
* jecxz:                                 Jump Instructions.
* JG:                                    Jump Instructions.
* jg:                                    Jump Instructions.
* jge:                                   Jump Instructions.
* JGE:                                   Jump Instructions.
* jl:                                    Jump Instructions.
* JL:                                    Jump Instructions.
* jle:                                   Jump Instructions.
* JLE:                                   Jump Instructions.
* JMP:                                   Jump Instructions.
* jmpb:                                  Jump Instructions.
* jmpf:                                  Jump Instructions.
* jmpfd:                                 Jump Instructions.
* jmpl:                                  Jump Instructions.
* jna:                                   Jump Instructions.
* JNA:                                   Jump Instructions.
* jnae:                                  Jump Instructions.
* JNAE:                                  Jump Instructions.
* jnb:                                   Jump Instructions.
* JNB:                                   Jump Instructions.
* JNBE:                                  Jump Instructions.
* jnbe:                                  Jump Instructions.
* jnc:                                   Jump Instructions.
* JNC:                                   Jump Instructions.
* jne:                                   Jump Instructions.
* JNE:                                   Jump Instructions.
* JNG:                                   Jump Instructions.
* jng:                                   Jump Instructions.
* JNGE:                                  Jump Instructions.
* jnge:                                  Jump Instructions.
* jnl:                                   Jump Instructions.
* JNL:                                   Jump Instructions.
* jnle:                                  Jump Instructions.
* JNLE:                                  Jump Instructions.
* jno:                                   Jump Instructions.
* JNO:                                   Jump Instructions.
* jnp:                                   Jump Instructions.
* JNP:                                   Jump Instructions.
* jns:                                   Jump Instructions.
* JNS:                                   Jump Instructions.
* jnz:                                   Jump Instructions.
* JNZ:                                   Jump Instructions.
* jo:                                    Jump Instructions.
* JO:                                    Jump Instructions.
* jp:                                    Jump Instructions.
* JP:                                    Jump Instructions.
* jpe:                                   Jump Instructions.
* JPE:                                   Jump Instructions.
* JPO:                                   Jump Instructions.
* jpo:                                   Jump Instructions.
* JS:                                    Jump Instructions.
* js:                                    Jump Instructions.
* Jump if above:                         Jump Instructions.
* Jump if above or equal:                Jump Instructions.
* Jump if below:                         Jump Instructions.
* Jump if below or equal:                Jump Instructions.
* Jump if carry:                         Jump Instructions.
* Jump if equal:                         Jump Instructions.
* Jump if greater:                       Jump Instructions.
* Jump if greater or equal:              Jump Instructions.
* Jump if less:                          Jump Instructions.
* Jump if less or equal:                 Jump Instructions.
* Jump if not above:                     Jump Instructions.
* Jump if not above nor equal:           Jump Instructions.
* Jump if not below:                     Jump Instructions.
* Jump if not below nor equal:           Jump Instructions.
* Jump if not carry:                     Jump Instructions.
* Jump if not equal:                     Jump Instructions.
* Jump if not greater:                   Jump Instructions.
* Jump if not greater nor equal:         Jump Instructions.
* Jump if not less:                      Jump Instructions.
* Jump if not less nor equal:            Jump Instructions.
* Jump if not overflow:                  Jump Instructions.
* Jump if not parity:                    Jump Instructions.
* Jump if not sign:                      Jump Instructions.
* Jump if not zero:                      Jump Instructions.
* Jump if overflow:                      Jump Instructions.
* Jump if parity:                        Jump Instructions.
* Jump if parity even:                   Jump Instructions.
* Jump if parity odd:                    Jump Instructions.
* Jump if sign:                          Jump Instructions.
* Jump if zero:                          Jump Instructions.
* jz:                                    Jump Instructions.
* JZ:                                    Jump Instructions.
* lahf:                                  Flag Control Instructions.
* LAHF:                                  Flag Control Instructions.
* lds:                                   Data Transfer Instructions.
* LDS:                                   Data Transfer Instructions.
* lea:                                   Data Transfer Instructions.
* LEA:                                   Data Transfer Instructions.
* leave:                                 Subroutine Handling Instructions.
* LEAVE:                                 Subroutine Handling Instructions.
* les:                                   Data Transfer Instructions.
* LES:                                   Data Transfer Instructions.
* lfs:                                   Data Transfer Instructions.
* LFS:                                   Data Transfer Instructions.
* lgs:                                   Data Transfer Instructions.
* LGS:                                   Data Transfer Instructions.
* Load AH from flags:                    Flag Control Instructions.
* Load effective address:                Data Transfer Instructions.
* Load register and DS:                  Data Transfer Instructions.
* Load register and ES:                  Data Transfer Instructions.
* Load register and FS:                  Data Transfer Instructions.
* Load register and GS:                  Data Transfer Instructions.
* Load register and SS:                  Data Transfer Instructions.
* Load string (byte):                    String Handling Instructions.
* Load string (double word):             String Handling Instructions.
* Load string (word):                    String Handling Instructions.
* LODSB:                                 String Handling Instructions.
* lodsb:                                 String Handling Instructions.
* LODSD:                                 String Handling Instructions.
* lodsd:                                 String Handling Instructions.
* lodsw:                                 String Handling Instructions.
* LODSW:                                 String Handling Instructions.
* Logical AND:                           Logic Instructions.
* Logical NOT:                           Logic Instructions.
* Logical OR (exclusive):                Logic Instructions.
* Logical OR (inclusive):                Logic Instructions.
* Loop:                                  Loop Handling Instructions.
* LOOP:                                  Loop Handling Instructions.
* loop:                                  Loop Handling Instructions.
* Loop while equal:                      Loop Handling Instructions.
* Loop while not equal:                  Loop Handling Instructions.
* Loop while not zero:                   Loop Handling Instructions.
* Loop while zero:                       Loop Handling Instructions.
* LOOPE:                                 Loop Handling Instructions.
* loope:                                 Loop Handling Instructions.
* LOOPNE:                                Loop Handling Instructions.
* loopne:                                Loop Handling Instructions.
* LOOPNZ:                                Loop Handling Instructions.
* loopnz:                                Loop Handling Instructions.
* loopz:                                 Loop Handling Instructions.
* LOOPZ:                                 Loop Handling Instructions.
* LSS:                                   Data Transfer Instructions.
* lss:                                   Data Transfer Instructions.
* Make stack frame:                      Subroutine Handling Instructions.
* MOV:                                   Data Transfer Instructions.
* mov:                                   Data Transfer Instructions.
* Move:                                  Data Transfer Instructions.
* Move (sign-extended):                  Data Transfer Instructions.
* Move (zero-extended):                  Data Transfer Instructions.
* Move string (byte):                    String Handling Instructions.
* Move string (double word):             String Handling Instructions.
* Move string (word):                    String Handling Instructions.
* movsb:                                 String Handling Instructions.
* MOVSB:                                 String Handling Instructions.
* movsd:                                 String Handling Instructions.
* MOVSD:                                 String Handling Instructions.
* movsw:                                 String Handling Instructions.
* MOVSW:                                 String Handling Instructions.
* MOVSX:                                 Data Transfer Instructions.
* movsx:                                 Data Transfer Instructions.
* movzx:                                 Data Transfer Instructions.
* MOVZX:                                 Data Transfer Instructions.
* mul:                                   Arithmetic Instructions.
* MUL:                                   Arithmetic Instructions.
* Multiply byte or word (unsigned):      Arithmetic Instructions.
* neg:                                   Arithmetic Instructions.
* NEG:                                   Arithmetic Instructions.
* Negate byte or word:                   Arithmetic Instructions.
* not:                                   Logic Instructions.
* NOT:                                   Logic Instructions.
* or:                                    Logic Instructions.
* OR:                                    Logic Instructions.
* pop:                                   Subroutine Handling Instructions.
* POP:                                   Subroutine Handling Instructions.
* Pop all 16-bit general registers:      Subroutine Handling Instructions.
* Pop all 32-bit general registers:      Subroutine Handling Instructions.
* Pop flags from stack:                  Subroutine Handling Instructions.
* Pop operand from stack:                Subroutine Handling Instructions.
* POPA:                                  Subroutine Handling Instructions.
* popa:                                  Subroutine Handling Instructions.
* POPAD:                                 Subroutine Handling Instructions.
* popad:                                 Subroutine Handling Instructions.
* popf:                                  Subroutine Handling Instructions.
* POPF:                                  Subroutine Handling Instructions.
* push:                                  Subroutine Handling Instructions.
* PUSH:                                  Subroutine Handling Instructions.
* Push all 16-bit general registers:     Subroutine Handling Instructions.
* Push all 32-bit general registers:     Subroutine Handling Instructions.
* Push flags onto stack:                 Subroutine Handling Instructions.
* Push operand onto stack:               Subroutine Handling Instructions.
* pusha:                                 Subroutine Handling Instructions.
* PUSHA:                                 Subroutine Handling Instructions.
* PUSHAD:                                Subroutine Handling Instructions.
* pushad:                                Subroutine Handling Instructions.
* PUSHF:                                 Subroutine Handling Instructions.
* pushf:                                 Subroutine Handling Instructions.
* rcl:                                   Rotate Instructions.
* RCL:                                   Rotate Instructions.
* rcr:                                   Rotate Instructions.
* RCR:                                   Rotate Instructions.
* Release stack frame:                   Subroutine Handling Instructions.
* rep:                                   String Handling Instructions.
* REP:                                   String Handling Instructions.
* REPE:                                  String Handling Instructions.
* repe:                                  String Handling Instructions.
* Repeat while not end of string:        String Handling Instructions.
* Repeat while not end of string and strings are equal: String Handling Instructions.
* Repeat while not end of string and strings are not equal: String Handling Instructions.
* repne:                                 String Handling Instructions.
* REPNE:                                 String Handling Instructions.
* repnz:                                 String Handling Instructions.
* REPNZ:                                 String Handling Instructions.
* repz:                                  String Handling Instructions.
* REPZ:                                  String Handling Instructions.
* RET:                                   Subroutine Handling Instructions.
* ret:                                   Subroutine Handling Instructions.
* Return from subroutine:                Subroutine Handling Instructions.
* ROL:                                   Rotate Instructions.
* rol:                                   Rotate Instructions.
* ROR:                                   Rotate Instructions.
* ror:                                   Rotate Instructions.
* Rotate left:                           Rotate Instructions.
* Rotate left through carry:             Rotate Instructions.
* Rotate right:                          Rotate Instructions.
* Rotate right through carry:            Rotate Instructions.
* SAHF:                                  Flag Control Instructions.
* sahf:                                  Flag Control Instructions.
* sal:                                   Shift Instructions.
* SAL:                                   Shift Instructions.
* SAR:                                   Shift Instructions.
* sar:                                   Shift Instructions.
* SBB:                                   Arithmetic Instructions.
* sbb:                                   Arithmetic Instructions.
* Scan string (byte):                    String Handling Instructions.
* Scan string (double word):             String Handling Instructions.
* Scan string (word):                    String Handling Instructions.
* scasb:                                 String Handling Instructions.
* SCASB:                                 String Handling Instructions.
* SCASD:                                 String Handling Instructions.
* scasd:                                 String Handling Instructions.
* scasw:                                 String Handling Instructions.
* SCASW:                                 String Handling Instructions.
* Set byte if above:                     Compare and Set Instructions.
* Set byte if above or equal:            Compare and Set Instructions.
* Set byte if below:                     Compare and Set Instructions.
* Set byte if below or equal:            Compare and Set Instructions.
* Set byte if carry:                     Compare and Set Instructions.
* Set byte if equal:                     Compare and Set Instructions.
* Set byte if greater:                   Compare and Set Instructions.
* Set byte if greater or equal:          Compare and Set Instructions.
* Set byte if less:                      Compare and Set Instructions.
* Set byte if less or equal:             Compare and Set Instructions.
* Set byte if not above:                 Compare and Set Instructions.
* Set byte if not above or equal:        Compare and Set Instructions.
* Set byte if not below:                 Compare and Set Instructions.
* Set byte if not below or equal:        Compare and Set Instructions.
* Set byte if not carry:                 Compare and Set Instructions.
* Set byte if not equal:                 Compare and Set Instructions.
* Set byte if not greater:               Compare and Set Instructions.
* Set byte if not greater or equal:      Compare and Set Instructions.
* Set byte if not less:                  Compare and Set Instructions.
* Set byte if not less or equal:         Compare and Set Instructions.
* Set byte if not overflow:              Compare and Set Instructions.
* Set byte if not parity:                Compare and Set Instructions.
* Set byte if not sign:                  Compare and Set Instructions.
* Set byte if not zero:                  Compare and Set Instructions.
* Set byte if overflow:                  Compare and Set Instructions.
* Set byte if parity:                    Compare and Set Instructions.
* Set byte if parity even:               Compare and Set Instructions.
* Set byte if parity odd:                Compare and Set Instructions.
* Set byte if sign:                      Compare and Set Instructions.
* Set byte if zero:                      Compare and Set Instructions.
* Set carry flag:                        Flag Control Instructions.
* Set DF:                                String Handling Instructions.
* Set interrupt flag:                    Flag Control Instructions.
* SETA:                                  Compare and Set Instructions.
* seta:                                  Compare and Set Instructions.
* SETAE:                                 Compare and Set Instructions.
* setae:                                 Compare and Set Instructions.
* setb:                                  Compare and Set Instructions.
* SETB:                                  Compare and Set Instructions.
* setbe:                                 Compare and Set Instructions.
* SETBE:                                 Compare and Set Instructions.
* setc:                                  Compare and Set Instructions.
* SETC:                                  Compare and Set Instructions.
* SETE:                                  Compare and Set Instructions.
* sete:                                  Compare and Set Instructions.
* setg:                                  Compare and Set Instructions.
* SETG:                                  Compare and Set Instructions.
* SETGE:                                 Compare and Set Instructions.
* setge:                                 Compare and Set Instructions.
* setl:                                  Compare and Set Instructions.
* SETL:                                  Compare and Set Instructions.
* setle:                                 Compare and Set Instructions.
* SETLE:                                 Compare and Set Instructions.
* setna:                                 Compare and Set Instructions.
* SETNA:                                 Compare and Set Instructions.
* setnae:                                Compare and Set Instructions.
* SETNAE:                                Compare and Set Instructions.
* SETNB:                                 Compare and Set Instructions.
* setnb:                                 Compare and Set Instructions.
* setnbe:                                Compare and Set Instructions.
* SETNBE:                                Compare and Set Instructions.
* SETNC:                                 Compare and Set Instructions.
* setnc:                                 Compare and Set Instructions.
* setne:                                 Compare and Set Instructions.
* SETNE:                                 Compare and Set Instructions.
* setng:                                 Compare and Set Instructions.
* SETNG:                                 Compare and Set Instructions.
* setnge:                                Compare and Set Instructions.
* SETNGE:                                Compare and Set Instructions.
* setnl:                                 Compare and Set Instructions.
* SETNL:                                 Compare and Set Instructions.
* setnle:                                Compare and Set Instructions.
* SETNLE:                                Compare and Set Instructions.
* setno:                                 Compare and Set Instructions.
* SETNO:                                 Compare and Set Instructions.
* setnp:                                 Compare and Set Instructions.
* SETNP:                                 Compare and Set Instructions.
* SETNS:                                 Compare and Set Instructions.
* setns:                                 Compare and Set Instructions.
* SETNZ:                                 Compare and Set Instructions.
* setnz:                                 Compare and Set Instructions.
* SETO:                                  Compare and Set Instructions.
* seto:                                  Compare and Set Instructions.
* setp:                                  Compare and Set Instructions.
* SETP:                                  Compare and Set Instructions.
* SETPE:                                 Compare and Set Instructions.
* setpe:                                 Compare and Set Instructions.
* setpo:                                 Compare and Set Instructions.
* SETPO:                                 Compare and Set Instructions.
* sets:                                  Compare and Set Instructions.
* SETS:                                  Compare and Set Instructions.
* setz:                                  Compare and Set Instructions.
* SETZ:                                  Compare and Set Instructions.
* Shift arithmetic left:                 Shift Instructions.
* Shift arithmetic right:                Shift Instructions.
* Shift logical left:                    Shift Instructions.
* Shift logical right:                   Shift Instructions.
* shl:                                   Shift Instructions.
* SHL:                                   Shift Instructions.
* SHLD:                                  Shift Instructions.
* shr:                                   Shift Instructions.
* SHR:                                   Shift Instructions.
* SHRD:                                  Shift Instructions.
* stc:                                   Flag Control Instructions.
* STC:                                   Flag Control Instructions.
* std:                                   String Handling Instructions.
* STI:                                   Flag Control Instructions.
* sti:                                   Flag Control Instructions.
* Store AH into flags:                   Flag Control Instructions.
* Store string (byte):                   String Handling Instructions.
* Store string (double word):            String Handling Instructions.
* Store string (word):                   String Handling Instructions.
* stosb:                                 String Handling Instructions.
* STOSB:                                 String Handling Instructions.
* stosd:                                 String Handling Instructions.
* STOSD:                                 String Handling Instructions.
* stosw:                                 String Handling Instructions.
* STOSW:                                 String Handling Instructions.
* SUB:                                   Arithmetic Instructions.
* sub:                                   Arithmetic Instructions.
* Subroutine call:                       Subroutine Handling Instructions.
* Subtract byte or word:                 Arithmetic Instructions.
* Subtract byte or word with borrow:     Arithmetic Instructions.
* Translat (allows segment override):    Data Transfer Instructions.
* Translat (must use DS):                Data Transfer Instructions.
* Unconditional jump:                    Jump Instructions.
* XCHG:                                  Data Transfer Instructions.
* xchg:                                  Data Transfer Instructions.
* XLAT:                                  Data Transfer Instructions.
* xlat:                                  Data Transfer Instructions.
* xlatb:                                 Data Transfer Instructions.
* XOR:                                   Logic Instructions.
* xor:                                   Logic Instructions.



Tag Table:
Node: Top211
Node: Introduction1217
Node: Disclaimer1509
Node: Description2148
Node: History3407
Node: Overview4813
Node: Features5208
Node: Differences6126
Node: Limitations7357
Node: Invocation8538
Node: Applications9875
Node: Language10533
Node: Syntax11015
Node: General11651
Node: Data16261
Node: Structures17308
Node: Structures and Unions17796
Node: Enumerations22669
Node: Prefixes24546
Node: Mnemonics26339
Node: Data Transfer Instructions27000
Node: Arithmetic Instructions27768
Node: Logic Instructions29417
Node: Shift Instructions29840
Ref: shxd30603
Node: Rotate Instructions32966
Node: Bit Test and Bit Scan Instructions33411
Node: Flag Control Instructions33962
Node: Compare and Set Instructions34556
Node: Jump Instructions36359
Node: Subroutine Handling Instructions38771
Node: Loop Handling Instructions39779
Node: String Handling Instructions40276
Node: Examples41782
Node: Hello world42154
Node: Enumeration types42804
Node: Opcode prefixes45225
Node: Contributors46136
Node: References47020
Ref: Triebel-199247133
Node: Topic Index47301
Node: Keyword Index48768
Node: Mnemonic Index50689

End Tag Table
